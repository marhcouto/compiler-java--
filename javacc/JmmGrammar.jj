PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< ASSIGNMENT : "="> |
	< AND : "&&" > |
	<LT: "<"> |
	< EQUALS : "==" > | 
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< INTEGER_LITERAL : (["0" - "9"])+ > |
	< OPEN_RECT_PAREN : "[" > |
	< CLOSE_RECT_PAREN : "]" > |
	< OPEN_BRACKET : "{" > |
	< CLOSE_BRACKET : "}" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |
	< INT : "int" > | 
	< BOOLEAN : "boolean" > |
	< STRING : "String" > | 
	< MAIN : "main" > |
	< RETURN : "return" > |
	< EOE : ";" > |
	< COMMA : "," > |
	< NOT : "!"> |
	< DOT : "." > |
	< LENGTH : "length"> |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	<IMPORT : "import"> |
	< ID : (("_" | ["A" - "Z"] | ["a" - "z"])("_" | ["0" - "9"] | ["A" - "Z"] | ["a" - "z"])*) >
;

Start: ImportDeclaration ClassDeclaration <EOF>;

ImportDeclaration: (<IMPORT> <ID> (<DOT> <ID>)* <EOE>)*;

ClassDeclaration: <CLASS> <ID> (<EXTENDS> <ID>)? <OPEN_BRACKET>
    (
        VarDeclaration |
        MethodDeclaration
    )*
<CLOSE_BRACKET>;

VarDeclaration: Type <ID> <EOE>;

MethodDeclaration: (<PUBLIC> MethodDeclarationSufix);

MethodDeclarationSufix: ((<STATIC> <VOID> <MAIN>  <OPEN_PAREN> <STRING> <OPEN_RECT_PAREN> <CLOSE_RECT_PAREN> <ID> <CLOSE_PAREN>) |
    (Type <ID> <OPEN_PAREN>
        (
            Type <ID> (<COMMA> Type <ID>)*
        )?
    <CLOSE_PAREN>))
    <OPEN_BRACKET>
            (
                VarDeclaration |
                Statement
            )*
    <CLOSE_BRACKET>
;

Type: <INT> (<OPEN_RECT_PAREN> <CLOSE_RECT_PAREN>)? |
    <BOOLEAN>
;

Statement: (<OPEN_BRACKET> Statement <CLOSE_BRACKET>) |
    (<IF> <OPEN_PAREN>Expression<CLOSE_PAREN> Statement <ELSE> Statement) |
    (<WHILE> <OPEN_PAREN>Expression<CLOSE_PAREN> Statement) |
    (Expression <EOE>) |
    (<ID> AssignmentStatement);

AssignmentStatement: (<ASSIGNMENT> Expression <EOE>) |
    (<OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN> <ASSIGNMENT> Expression <EOE>)
;

Expression: ExpressionPrefix ExpressionSufix;

ExpressionPrefix: <INTEGER_LITERAL> |
    <TRUE> |
    <FALSE> |
    <ID> |
    <THIS> |
    <NEW> CreatedObject |
    <NOT> Expression |
    <OPEN_PAREN>Expression<CLOSE_PAREN>
;

ExpressionSufix: ((<OPEN_RECT_PAREN> Expression <CLOSE_RECT_PAREN>) |
    (<DOT> ExpressionCall))?
;

CreatedObject: <INT> <OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN> |
    <ID> <OPEN_PAREN> <CLOSE_PAREN>
;

ExpressionCall: <LENGTH> |
    <ID> <OPEN_PAREN>
        (Expression (<COMMA> Expression)*)?
    <CLOSE_PAREN>
;

AndExpression: LessThanExpression ( <AND> LessThanExpression)*;

LessThanExpression: AdditiveExpression ( <LT> AdditiveExpression)*;

AdditiveExpression: MultiplicativeExpression ( <PLUS> MultiplicativeExpression)* |
    MultiplicativeExpression ( <MINUS> MultiplicativeExpression)*
;

MultiplicativeExpression: UnaryOperator ( <TIMES> UnaryOperator)* |
    UnaryOperator ( <DIVIDE> UnaryOperator)*
;

UnaryOperator: <MINUS> Factor |
                Factor;

Factor : Expression |
    <OPEN_PAREN> AndExpression <CLOSE_PAREN>;