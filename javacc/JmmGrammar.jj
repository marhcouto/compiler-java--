PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< ASSIGNMENT : "="> |
	< AND : "&&" > |
	<LT: "<"> |
	< EQUALS : "==" > | 
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< INTEGER_LITERAL : (["0" - "9"])+ > |
	< OPEN_RECT_PAREN : "[" > |
	< CLOSE_RECT_PAREN : "]" > |
	< OPEN_BRACKET : "{" > |
	< CLOSE_BRACKET : "}" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |
	< INT : "int" > | 
	< BOOLEAN : "boolean" > |
	< STRING : "String" > | 
	< MAIN : "main" > |
	< RETURN : "return" > |
	< EOE : ";" > |
	< COMMA : "," > |
	< NOT : "!"> |
	< DOT : "." > |
	< LENGTH : "length"> |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< PRIVATE : "private" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	<IMPORT : "import"> |
	< ID : ((["A" - "Z"] | ["a" - "z"])(["0" - "9"] | ["A" - "Z"] | ["a" - "z"])*) >
;

Start: ImportDeclaration ClassDeclaration <EOF>;

ImportDeclaration: (<IMPORT> <ID> (<DOT> <ID>)* <EOE>)*;

ClassDeclaration: <CLASS> <ID> (<EXTENDS> <ID>)? <OPEN_BRACKET>
    (VarDeclaration)* |
    (MethodDeclaration)*
<CLOSE_BRACKET>;

VarDeclaration: Type <ID> <EOE>;

MethodDeclaration: <PUBLIC> Type <ID> <OPEN_PAREN>
    (
        Type <ID> (<COMMA> Type <ID>)*
    )?
<CLOSE_PAREN>
<OPEN_BRACKET>
    (VarDeclaration)*
    (Statement)*
<CLOSE_BRACKET>;

Type: <INT> <OPEN_RECT_PAREN> <CLOSE_RECT_PAREN> |
    <BOOLEAN> |
    <INT> |
    <ID>
;

Statement: <OPEN_BRACKET> Statement <CLOSE_BRACKET> |
    <IF> <OPEN_PAREN>Expression<CLOSE_PAREN> Statement <ELSE> Statement |
    <WHILE> <OPEN_PAREN>Expression<CLOSE_PAREN> Statement |
    Expression <EOE> |
    <ID> <ASSIGNMENT> Expression <EOE> |
    <ID> <OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN> <ASSIGNMENT> Expression <EOE>;

ExpressionPrefix: <INTEGER_LITERAL> |
    <TRUE> |
    <FALSE> |
    <ID> |
    <THIS> |
    <NEW> <INT> <OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN> |
    <NEW> <ID> <OPEN_PAREN> <CLOSE_PAREN> |
    <NOT> Expression |
    <OPEN_PAREN>Expression<CLOSE_PAREN>
;

ExpressionSufix: (<OPEN_RECT_PAREN> Expression <CLOSE_RECT_PAREN> |
    <DOT> <LENGTH> |
    <DOT> <ID> <OPEN_PAREN>
        (Expression (<COMMA> Expression)*)?
    <CLOSE_PAREN>)?
;

Expression: ExpressionPrefix ExpressionSufix;