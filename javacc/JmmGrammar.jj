PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP : " " | "\t" | "\r" | "\n" | <("//" (["0" - "9"])*)>;

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< ASSIGNMENT : "="> |
	< AND : "&&" > |
	<LT : "<"> |
	< EQUALS : "==" > | 
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< INTEGER_LITERAL : (["0" - "9"])+ > |
	< OPEN_RECT_PAREN : "[" > |
	< CLOSE_RECT_PAREN : "]" > |
	< OPEN_BRACKET : "{" > |
	< CLOSE_BRACKET : "}" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |
	< INT : "int" > | 
	< BOOLEAN : "boolean" > |
	< STRING : "String" > | 
	< MAIN : "main" > |
	< RETURN : "return" > |
	< EOE : ";" > |
	< COMMA : "," > |
	< NOT : "!"> |
	< DOT : "." > |
	< LENGTH : "length"> |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	<IMPORT : "import"> |
	< ID : (("_" | ["A" - "Z"] | ["a" - "z"])("_" | ["0" - "9"] | ["A" - "Z"] | ["a" - "z"])*) >
;

Start: ImportDeclaration ClassDeclaration <EOF>;

ImportDeclaration: (<IMPORT> <ID> (<DOT> <ID>)* <EOE>)*;

ClassDeclaration: <CLASS> <ID> (<EXTENDS> <ID>)? <OPEN_BRACKET>
    (
        VarDeclaration |
        MethodDeclaration
    )*
<CLOSE_BRACKET>;

MethodDeclaration: (<PUBLIC> (MethodDeclarationSufix | MainMethodDeclarationSufix));

MainMethodDeclarationSufix: (<STATIC> <VOID> <MAIN>  <OPEN_PAREN> <STRING> <OPEN_RECT_PAREN> <CLOSE_RECT_PAREN> <ID> <CLOSE_PAREN>)
    <OPEN_BRACKET>
        (
            (SCAN 2 VarDeclaration |
                Statement)
            )*
    <CLOSE_BRACKET>
;

MethodDeclarationSufix: (Type <ID> <OPEN_PAREN>
        (
            Type <ID> (<COMMA> Type <ID>)*
        )?
    <CLOSE_PAREN>)
    <OPEN_BRACKET>
            (
                (SCAN 2 VarDeclaration |
                Statement)
            )*
            <RETURN> Expression <EOE>
    <CLOSE_BRACKET>
;

VarDeclaration: Type <ID> <EOE>;

Type: <INT> (<OPEN_RECT_PAREN> <CLOSE_RECT_PAREN>)? |
    <BOOLEAN> |
    <ID>
;

Statement #void: (<OPEN_BRACKET> (Statement)* <CLOSE_BRACKET>) |
    (<IF> <OPEN_PAREN>Expression<CLOSE_PAREN> StmBody <ELSE> StmBody) #IfStm(3) |
    (<WHILE> <OPEN_PAREN>Expression<CLOSE_PAREN> StmBody) #WhileStm(2) |
    IDStatement <EOE>;

StmBody: Statement;

IDStatement #void: ((<ID> #VarName) (AssignmentStatement | ExpressionSufix)) | (ExpressionPrefix ExpressionSufix);

AssignmentStatement #void: (<ASSIGNMENT> Expression) #AsmOp(2) |
    (<OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN> <ASSIGNMENT> Expression) #ArrAsmOp(3)
;

Expression #void: ExpressionPrefix ExpressionSufix;
ExpressionPrefix #void: AndExpression |
    <INTEGER_LITERAL> #IntegerLiteral |
    <TRUE> #BooleanLiteral |
    <FALSE> #BooleanLiteral |
    <THIS> #ObjectLiteral |
    (<NEW> CreatedObject) |
    (<NOT> Expression) #UnaryOp |
    <OPEN_PAREN>Expression<CLOSE_PAREN>
;

ExpressionSufix #void: ((<OPEN_RECT_PAREN> Expression <CLOSE_RECT_PAREN>) |
    (<DOT> ExpressionCall) #FnCallOp(3))?
;

CreatedObject #void: (<INT> <OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN>) #CreateArrObj(2) |
    (<ID> #ObjName <OPEN_PAREN> <CLOSE_PAREN>) #CreateObj
;

ExpressionCall #void: (<LENGTH> #Length) |
    (<ID> #MethodName <OPEN_PAREN>)
        ArgumentList
    <CLOSE_PAREN>
;

ArgumentList: (Expression (<COMMA> Expression)*)?;

AndExpression #void: LessThanExpression (
    (<AND> LessThanExpression) #BinOp(2)
)*;

LessThanExpression #void: AdditiveExpression (
    (<LT> AdditiveExpression) #BinOp(2)
)*;

AdditiveExpression #void: MultiplicativeExpression (
    (<PLUS> MultiplicativeExpression) #BinOp(2) |
    (<MINUS> MultiplicativeExpression) #BinOp(2)
)*;

MultiplicativeExpression #void: UnaryOperator (
    (<TIMES> UnaryOperator) #BinOp(2) |
    (<DIVIDE> UnaryOperator) #BinOp(2)
)*;

UnaryOperatorPrefix #void: <INTEGER_LITERAL> #IntegerLiteral  |
    <TRUE> #BooleanLiteral |
    <FALSE> #BooleanLiteral |
    <THIS> #ObjectLiteral |
    (<NEW> CreatedObject) #UnaryOp |
    (<NOT> Expression) #UnaryOp |
    <OPEN_PAREN>Expression<CLOSE_PAREN> |
    (<MINUS> Expression) #UnaryOp |
    <ID> #VarName;

UnaryOperator #void: UnaryOperatorPrefix ExpressionSufix;

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}
