PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP : " " | "\t" | "\r" | "\n" | <("//" (["0" - "9"])*)>;

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< ASSIGNMENT : "="> |
	< AND : "&&" > |
	<LT : "<"> |
	< EQUALS : "==" > | 
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< INTEGER_LITERAL : (["0" - "9"])+ > |
	< OPEN_RECT_PAREN : "[" > |
	< CLOSE_RECT_PAREN : "]" > |
	< OPEN_BRACKET : "{" > |
	< CLOSE_BRACKET : "}" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |
	< INT : "int" > | 
	< BOOLEAN : "boolean" > |
	< STRING : "String" > | 
	< MAIN : "main" > |
	< RETURN : "return" > |
	< EOE : ";" > |
	< COMMA : "," > |
	< NOT : "!"> |
	< DOT : "." > |
	< LENGTH : "length"> |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	<IMPORT : "import"> |
	< ID : (("_" | ["A" - "Z"] | ["a" - "z"])("_" | ["0" - "9"] | ["A" - "Z"] | ["a" - "z"])*) >
;

Start: ImportDeclarations ClassDeclaration <EOF>;

ImportDeclarations #void: (ImportDeclaration)*;

ImportDeclaration: <IMPORT> ((<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #ImportPath) (
    <DOT> (<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #ImportPath
)* <EOE>;


ClassDeclaration: <CLASS> ((<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #ClassName) (<EXTENDS> (<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #ClassParent)? <OPEN_BRACKET>
    (
        VarDeclaration |
        MethodDeclaration
    )*
<CLOSE_BRACKET>;

MethodDeclaration #void: (<PUBLIC> (MethodDeclarationSufix | MainMethodDeclarationSufix));

MainMethodDeclarationSufix: (<STATIC> <VOID> <MAIN>  <OPEN_PAREN> <STRING> <OPEN_RECT_PAREN> <CLOSE_RECT_PAREN> (<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #MainArgsName <CLOSE_PAREN>)
    <OPEN_BRACKET>
        MethodBody
    <CLOSE_BRACKET>
;

MethodBody: (
        (SCAN 2 VarDeclaration |
        Statement)
)*;

MethodDeclarationSufix: (Type <ID> <OPEN_PAREN>
        MethodArgsList
    <CLOSE_PAREN>)
    <OPEN_BRACKET>
            MethodBody
            ReturnStatement
    <CLOSE_BRACKET>
;

ReturnStatement: <RETURN> Expression <EOE>;

MethodArgsList: (MethodArg (<COMMA> MethodArg)*)?;

MethodArg: (Type) (
    <ID> { jjtThis.put("image", lastConsumedToken.getImage()); }
) #ArgName;

VarDeclaration: (Type) (
    <ID> { jjtThis.put("image", lastConsumedToken.getImage()); }
) #VarName <EOE>;

Type #void: (<INT> (<OPEN_RECT_PAREN> <CLOSE_RECT_PAREN>)?) #Type |
    (<BOOLEAN> { jjtThis.put("image", "bool"); }) #Type |
    (<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #Type
;

Statement #void: (<OPEN_BRACKET> (Statement)* <CLOSE_BRACKET>) |
    (<IF> <OPEN_PAREN>Expression<CLOSE_PAREN> StmBody <ELSE> StmBody) #IfStm(3) |
    (<WHILE> <OPEN_PAREN>Expression<CLOSE_PAREN> StmBody) #WhileStm(2) |
    IDStatement <EOE>;

StmBody: Statement;

IDStatement #void: (((<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #VarName) (AssignmentStatement | ExpressionSufix)) | (ExpressionPrefix ExpressionSufix);

AssignmentStatement #void: (<ASSIGNMENT> Expression) #AsmOp(2) |
    (<OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN> <ASSIGNMENT> Expression) #ArrAsmOp(3)
;

Expression #void: ExpressionPrefix ExpressionSufix;
ExpressionPrefix #void: AndExpression |
    (<INTEGER_LITERAL> { jjtThis.put("image", lastConsumedToken.getImage()); }) #IntegerLiteral |
    <TRUE> #True |
    <FALSE> #False |
    <THIS> #This |
    (<NEW> CreatedObject) |
    (<NOT> Expression { jjtThis.put("op", "NOT"); }) #UnaryOp |
    <OPEN_PAREN>Expression<CLOSE_PAREN>
;

ExpressionSufix #void: ((<OPEN_RECT_PAREN> Expression <CLOSE_RECT_PAREN>) |
    (<DOT> ExpressionCall) #FnCallOp(3))?
;

CreatedObject #void: (<INT> <OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN>) #CreateArrObj(2) |
    ((<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #ObjName <OPEN_PAREN> <CLOSE_PAREN>) #CreateObj
;

ExpressionCall #void: (<LENGTH> #Length) |
    ((<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #MethodName <OPEN_PAREN>)
        ArgumentList
    <CLOSE_PAREN>
;

ArgumentList: (Expression (<COMMA> Expression)*)?;

AndExpression #void: LessThanExpression (
    (<AND> LessThanExpression { jjtThis.put("op", "AND"); }) #BinOp(2)
)*;

LessThanExpression #void: AdditiveExpression (
    (<LT> AdditiveExpression { jjtThis.put("op", "LT"); }) #BinOp(2)
)*;

AdditiveExpression #void: MultiplicativeExpression (
    (<PLUS> MultiplicativeExpression { jjtThis.put("op", "ADD"); }) #BinOp(2) |
    (<MINUS> MultiplicativeExpression { jjtThis.put("op", "SUB"); } ) #BinOp(2)
)*;

MultiplicativeExpression #void: UnaryOperator (
    (<TIMES> UnaryOperator { jjtThis.put("op", "MUL"); }) #BinOp(2) |
    (<DIVIDE> UnaryOperator { jjtThis.put("op", "DIV"); }) #BinOp(2)
)*;

UnaryOperatorPrefix #void: (<INTEGER_LITERAL> { jjtThis.put("image", lastConsumedToken.getImage()); }) #IntegerLiteral  |
    <TRUE> #True |
    <FALSE> #False |
    <THIS> #This |
    (<NEW> CreatedObject) |
    (<NOT> Expression { jjtThis.put("op", "NOT"); } ) #UnaryOp |
    <OPEN_PAREN>Expression<CLOSE_PAREN> |
    (<MINUS> Expression { jjtThis.put("op", "SIM"); }) #UnaryOp |
    (<ID> { jjtThis.put("image", lastConsumedToken.getImage()); }) #VarName;

UnaryOperator #void: UnaryOperatorPrefix ExpressionSufix;

// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}
