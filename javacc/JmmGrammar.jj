PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< ASSIGNMENT : "="> |
	< AND : "&&" > |
	<LT : "<"> |
	< EQUALS : "==" > | 
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< INTEGER_LITERAL : (["0" - "9"])+ > |
	< OPEN_RECT_PAREN : "[" > |
	< CLOSE_RECT_PAREN : "]" > |
	< OPEN_BRACKET : "{" > |
	< CLOSE_BRACKET : "}" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |
	< INT : "int" > | 
	< BOOLEAN : "boolean" > |
	< STRING : "String" > | 
	< MAIN : "main" > |
	< RETURN : "return" > |
	< EOE : ";" > |
	< COMMA : "," > |
	< NOT : "!"> |
	< DOT : "." > |
	< LENGTH : "length"> |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< STATIC : "static" > |
	< VOID : "void" > |
	<IMPORT : "import"> |
	< ID : (("_" | ["A" - "Z"] | ["a" - "z"])("_" | ["0" - "9"] | ["A" - "Z"] | ["a" - "z"])*) >
;

Start: ImportDeclaration ClassDeclaration <EOF>;

ImportDeclaration: (<IMPORT> <ID> (<DOT> <ID>)* <EOE>)*;

ClassDeclaration: <CLASS> <ID> (<EXTENDS> <ID>)? <OPEN_BRACKET>
    (
        VarDeclaration |
        MethodDeclaration
    )*
<CLOSE_BRACKET>;

MethodDeclaration: (<PUBLIC> MethodDeclarationSufix);

MethodDeclarationSufix: ((<STATIC> <VOID> <MAIN>  <OPEN_PAREN> <STRING> <OPEN_RECT_PAREN> <CLOSE_RECT_PAREN> <ID> <CLOSE_PAREN>) |
    (Type <ID> <OPEN_PAREN>
        (
            Type <ID> (<COMMA> Type <ID>)*
        )?
    <CLOSE_PAREN>))
    <OPEN_BRACKET>
            (
                (SCAN 2 VarDeclaration |
                Statement)
            )*
    <CLOSE_BRACKET>
;

VarDeclaration: Type <ID> <EOE>;

Type: <INT> (<OPEN_RECT_PAREN> <CLOSE_RECT_PAREN>)? |
    <BOOLEAN> |
    <ID>
;

Statement: (<OPEN_BRACKET> (Statement)* <CLOSE_BRACKET>) |
    (<IF> <OPEN_PAREN>Expression<CLOSE_PAREN> Statement <ELSE> Statement) |
    (<WHILE> <OPEN_PAREN>Expression<CLOSE_PAREN> Statement) |
    IDStatement <EOE>;

IDStatement: (<ID> (AssignmentStatement | ExpressionSufix)) | (ExpressionPrefix ExpressionSufix);

AssignmentStatement: (<ASSIGNMENT> Expression) |
    (<OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN> <ASSIGNMENT> Expression)
;

Expression: (<ID> | ExpressionPrefix) (ExpressionSufix)?;
ExpressionPrefix: AndExpression |
    <INTEGER_LITERAL> |
    <TRUE> |
    <FALSE> |
    <THIS> |
    <NEW> CreatedObject |
    <NOT> Expression |
    <OPEN_PAREN>Expression<CLOSE_PAREN>
;

ExpressionSufix: ((<OPEN_RECT_PAREN> Expression <CLOSE_RECT_PAREN>) |
    (<DOT> ExpressionCall))?
;

CreatedObject: <INT> <OPEN_RECT_PAREN>Expression<CLOSE_RECT_PAREN> |
    <ID> <OPEN_PAREN> <CLOSE_PAREN>
;

ExpressionCall: <LENGTH> |
    <ID> <OPEN_PAREN>
        (Expression (<COMMA> Expression)*)?
    <CLOSE_PAREN>
;

AndExpression: (LessThanExpression ( <AND> LessThanExpression)*);

LessThanExpression: (AdditiveExpression ( <LT> AdditiveExpression)*);

AdditiveExpression: (MultiplicativeExpression ( <PLUS> MultiplicativeExpression)*) |
    (MultiplicativeExpression ( <MINUS> MultiplicativeExpression)*)
;

MultiplicativeExpression: (UnaryOperator ( <TIMES> UnaryOperator)*) |
    (UnaryOperator ( <DIVIDE> UnaryOperator)*)
;

UnaryOperatorPrefix: <INTEGER_LITERAL> |
    <TRUE> |
    <FALSE> |
    <THIS> |
    <NEW> CreatedObject |
    <NOT> Expression |
    <OPEN_PAREN>Expression<CLOSE_PAREN> |
    (<MINUS> Expression);

UnaryOperator: UnaryOperatorPrefix ExpressionSufix;
