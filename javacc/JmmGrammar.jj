PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< ASSIGNMENT : "="> |
	< AND : "&&" > | 
	< EQUALS : "==" > | 
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< DIGIT : (["0" - "9"])+ > |
	< OPEN_RECT_PAREN : "[" > |
	< CLOSE_RECT_PAREN : "]" > |
	< OPEN_BRACKET : "{" > |
	< CLOSE_BRACKET : "}" > |
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE : "false" > |
	< THIS : "this" > |
	< NEW : "new" > |
	< INT : "int" > | 
	< BOOLEAN : "boolean" > |
	< STRING : "String" > | 
	< MAIN : "main" > |
	< RETURN : "return" > |
	< EOE : ";" > |
	< COMMA : "," > |
	< NOT : "!"> |
	< DOT : "." > |
	< LENGTH : "length"> |
	< ID : ((["A" - "Z"] | ["a" - "z"])(["0" - "9"] | ["A" - "Z"] | ["a" - "z"])*) > |
	< CLASS : "class" > |
	< EXTENDS : "extends" > |
	< PUBLIC : "public" > |
	< PRIVATE : "private" > |
	< STATIC : "static" > |
	< VOID : "void" >
;

Start: ImportDeclaration ClassDeclaration <EOF> ;

ImportDeclaration : ImportDeclaration <EOE> (ImportDeclaration) * ;

ClassDeclaration : <CLASS> <ID> (<EXTENDS> <ID>)? <OPEN_BRACKET>
	(VarDeclaration | MethodDeclaration)*
<CLOSE_BRACKET>;

Type : <INT> <OPEN_RECT_PAREN> <CLOSE_RECT_PAREN> | <BOOLEAN> | <ID> ;

VarDeclaration : Type <ID> <EOE> ;

MethodDeclaration : <PUBLIC> Type <ID> ;

Callable :  <NEW> <INT> <OPEN_PAREN> Expression <CLOSE_PAREN> |
    <ID>
;

Expression : <ID> <OPEN_RECT_PAREN> Expression <CLOSE_RECT_PAREN> |
    Callable <DOT> <LENGTH> |
    Callable <DOT> <ID> <OPEN_PAREN> (
        Expression (
            <COMMA> Expression
        )*
    )* <CLOSE_PAREN> |
    <DIGIT> |
    <TRUE> |
    <FALSE> |
    <ID> |
    <THIS> |
    <NEW> <INT> <OPEN_PAREN> Expression <CLOSE_PAREN> |
    <NEW> <ID> <OPEN_PAREN> <CLOSE_PAREN> |
    <NOT> Expression |
    <OPEN_PAREN> Expression <OPEN_PAREN>
;

AdditiveExpression :
	MultiplicativeExpression
	(
		(< PLUS > | < MINUS >)
		MultiplicativeExpression
	)?
;

MultiplicativeExpression :
	Factor
	(
		(< TIMES > | < DIVIDE >)
		Factor
	)?
;

Factor :
	< DIGIT > |
	< MINUS> Factor |
	< OPEN_PAREN > AdditiveExpression < CLOSE_PAREN >
;
